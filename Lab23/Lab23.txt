#include <stdio.h>
#include <stdlib.h>

#define NODE 0
#define PARENT 1
#define OLDER_BROTHER 2

typedef struct Node Node;

struct Node
{
    int id;
    Node *son;
    Node *bro;
    int value;
};

void FindNodeR(int id, Node* root, Node** res) {
    if ((root->son != NULL) && (root->son->id == id)) {
        res[NODE] = root->son;
        res[PARENT] = root;
    } else if ((root->bro != NULL) && (root->bro->id == id)) {
        res[NODE] = root->bro;
        res[OLDER_BROTHER] = root;
    } else {
        if (root->son != NULL) FindNodeR(id, root->son, res);
        if (root->bro != NULL) FindNodeR(id, root->bro, res);
    }
}

void FindNode(int id, Node* root, Node** res) {
    res[NODE] = NULL;
    res[PARENT] = NULL;
    res[OLDER_BROTHER] = NULL;
    if (root->id == id) {
        res[NODE] = root;
    } else {
        FindNodeR(id, root, res);
    }
}

void AddNode(int dadId, int value, int *idCounter, Node** rootPtr) {
    Node *res[3];
    Node *root = *rootPtr;
    if (dadId == -1) {
        root = (Node*)malloc(sizeof(Node));
        root->bro = NULL;
        root->son = NULL;
        root->id = 0;
        root->value = value;
        *idCounter += 1;
        *rootPtr = root;
    } else {
        FindNode(dadId, root, res);
        if (res[NODE] != NULL) {
            Node *dad = res[NODE];
            Node *newNode = (Node*)malloc(sizeof(Node));
            newNode->value = value;
            newNode->id = *idCounter;
            *idCounter = *idCounter + 1;
            newNode->bro = NULL;
            newNode->son = NULL;
            if (dad != NULL) {
                if (dad->son == NULL) {
                    dad->son = newNode;
                } else {
                    Node *oldBro = dad->son;
                    while (oldBro->bro != NULL) {
                        oldBro = oldBro->bro;
                    }
                    oldBro->bro = newNode;
                }
            }
        }
    }
}

void DelNodeR(Node *node) {
    if (node->son != NULL) {
        DelNodeR(node->son);
    }
    if (node->bro != NULL) {
        DelNodeR(node->bro);
    }
    free(node);
}

void DelNode(int id, Node **rootPtr) {
    Node *root = *rootPtr;
    Node *res[3];
    FindNode(id, root, res);
    if (res[PARENT] != NULL) {
        res[PARENT]->son = res[NODE]->bro;
    } else if (res[OLDER_BROTHER] != NULL) {
        res[OLDER_BROTHER]->bro = res[NODE]->bro;
    }
    if (res[NODE]->son != NULL) {
        DelNodeR(res[NODE]->son);
    }
    free(res[NODE]);
    if (id == 0) root = NULL;
    *rootPtr = root;
}

void ChangeValue(int id, int value, Node *root) {
    Node *res[3];
    FindNode(id, root, res);
    res[NODE]->value = value;
}

void PrintTree(Node *root, int depth) {
    for(int i = 0; i < depth; i++) {
        if (i == depth - 1) printf(" |--");
        else printf(" |  ");
    }
    printf("%d:%d\n", root->id, root->value);
    if (root->son != NULL) {
        PrintTree(root->son, depth + 1);
    }
    if (root->bro != NULL) {
        PrintTree(root->bro, depth);
    }
}

void PrintTreeD(Node *root) {
    if (root != NULL){
        printf("------------\n");
        PrintTree(root, 0);
        printf("------------\n");
    } else {
        printf("empty\n");
    }
}

void Width(Node* root, int depth, int** res, int* depthMax) {
    if (depth >= *depthMax) {
        int newDepthMax = *depthMax * 2;
        *res = realloc(*res, newDepthMax * sizeof(int));
        for (int i = *depthMax; i < newDepthMax; i++) {
            (*res)[i] = -1;
        }
        *depthMax = newDepthMax;
    }
    if (depth < *depthMax) {
        (*res)[depth]++;
    }

    if (root->son != NULL) {
        Width(root->son, depth + 1, res, depthMax);
    }
    if (root->bro != NULL) {
        Width(root->bro, depth, res, depthMax);
    }
}


void CheckWidthMonot(int* res, int depthMax) {
    int curWidth = 0;
    int prevWidth = 1000;
    for (int i = 1; i < depthMax; i++) {
        curWidth = res[i] + 1;
        if (curWidth != 0 && curWidth > prevWidth) {
            printf("Not Monotonno\n");
            return;
        }
        prevWidth = curWidth;
    }
    printf("Monotonno\n");
}

void PrintHelp(){
    printf("a [dad id] [value] - add node\n");
    printf("d [id] - delete node\n");
    printf("c [id] [new value] - change value\n");
    printf("f - check width monotonnost\n");
    printf("p - print tree\n");
    printf("h - show this help\n");
    printf("q - quit the program\n");
    printf("node output id:value\n");
}

int main() {
    int idCounter = 0;
    char command;
    int arg1, arg2;
    Node* root = NULL;
    PrintTreeD(root);
    do {
        scanf("%c", &command);
        switch (command)
        {
            case 'a':
                scanf("%d %d", &arg1, &arg2);
                AddNode(arg1, arg2, &idCounter, &root);
                PrintTreeD(root);
                break;
            case 'd':
                scanf("%d", &arg1);
                DelNode(arg1, &root);
                PrintTreeD(root);
                break;
            case 'c':
                scanf("%d %d", &arg1, &arg2);
                ChangeValue(arg1, arg2, root);
                PrintTreeD(root);
                break;
            case 'p':
                PrintTreeD(root);
                break;
            case 'f':
                int depthMax = 2;
                int *res = (int*)malloc(sizeof(int) * depthMax);
                for (int i = 0; i < depthMax; i++) {
                    res[i] = -1;
                }
                Width(root, 0, &res, &depthMax);
                CheckWidthMonot(res, depthMax);
                break;
            case 'h':
                PrintHelp();
                break;
        }
    } while (command != 'q');
    return 0;
}


